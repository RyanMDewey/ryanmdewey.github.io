<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ryan's Blog</title>
  <meta name="description" content="Ryan Deweyâ€™s official blog: exploring sentient compilers, AI kernels, and quantum systems.">
  <meta name="author" content="Ryan Dewey">
  <meta property="og:title" content="ByteOfHeaven Journal">
  <meta property="og:description" content="Engineering the post-silicon era â€” one breakthrough at a time.">
  <meta property="og:image" content="https://ryanmdewey.github.io/blog/banner.jpg">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github-dark.min.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="/styles/main.css">
</head>
<body>
  
  <!-- âœ… Dynamic Nav Injection Target -->
  <div class="top-nav">
    <div class="nav-container" id="dynamic-nav"></div>
  </div>

  <!-- âœ… Dynamic Nav Injection Script -->
  <script>
    const currentPath = window.location.pathname;
    const currentPage = currentPath.split('/').pop() || 'index.html';

    const navLinks = [
      { name: 'Home', href: '/' },
      { name: 'Experience', href: '/experience.html' },
      { name: 'Projects', href: '/projects.html' },
      { name: 'Skills', href: '/skills.html' },
      { name: 'Resume', href: '/resume.html' },
      { name: 'Contact', href: '/contact.html' },
      { name: 'Blog', href: '/blog/' }
    ];

    const nav = document.createElement('div');
    nav.className = 'nav-links';

    navLinks.forEach(link => {
      const isActive = currentPage === link.href.split('/').pop() || currentPath === link.href;
      if (!isActive) {
        const a = document.createElement('a');
        a.href = link.href;
        a.textContent = link.name;
        nav.appendChild(a);
      }
    });

    document.getElementById('dynamic-nav')?.appendChild(nav);
  </script>
  
  <div class="blog-header">
  <h1 class="glitch">Ryan Deweyâ€™s Blog</h1>
  <p>Where I architect intelligence, decode quantum systems, and push code toward sentience.</p>
  <img src="banner.jpg" alt="ByteOfHeaven Banner" class="blog-banner">
  </div>
  
  <!-- âœ… CATEGORY FALLBACK (invisible to user) -->
  <p style="display: none;" id="fallback-category">AI</p>

    <div id="search-container">
      <input type="text" id="search-input" placeholder="Search posts...">
      <div id="search-results"></div>
  </div>

  <div id="filter-sort-box">
  <div id="filter-sort-button">Filter & Sort</div>
  <div id="filter-options" style="display: none;">
    <select id="filter-select">
      <optgroup label="ðŸ—‚ Categories">
        <option value="all">All Categories</option>
      </optgroup>
      <optgroup label="ðŸ•° Sort By">
        <option value="sort-newest">Newest First</option>
        <option value="sort-oldest">Oldest First</option>
      </optgroup>
    </select>
  </div>
</div>
  
    <div id="blog-list"></div>

  <div class="footer">
    âœ¨ This universe designed by Ryan Dewey Â© 2025<br>
    Powered by <strong>Lumina</strong> â€¢ AI-Native Runtime â€¢ Hosted on <a href="https://pages.github.com/" target="_blank" style="color:#00ffe1">GitHub Pages</a>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>
  <script>
document.addEventListener("DOMContentLoaded", async () => {
  // === Grab the containers for blog, search, and filter ===
  const blogContainer = document.getElementById("blog-list");
  const searchInput = document.getElementById("search-input");
  const searchResults = document.getElementById("search-results");
  const filterSelect = document.getElementById("filter-select");

  // === Helper function to format the published display ===
  // Merges the filename's true intended date with the commit time (hours/minutes)
  function formatPublishedDisplay(fileDate, commitDateTime, readTime) {
    const fileParts = fileDate.split("-").map(Number); // Break "2025-04-26" into [2025, 4, 26]
    const commit = new Date(commitDateTime); // GitHub commit timestamp

    // Merge the correct DAY (from filename) with the TIME (from GitHub)
    const mergedDate = new Date(fileParts[0], fileParts[1] - 1, fileParts[2], commit.getHours(), commit.getMinutes());

    // Define how to pretty-print the date and time separately
    const optionsDate = { year: 'numeric', month: 'long', day: 'numeric' };
    const optionsTime = { hour: 'numeric', minute: '2-digit', hour12: true };

    const prettyDate = mergedDate.toLocaleDateString(undefined, optionsDate); // "April 26, 2025"
    const prettyTime = mergedDate.toLocaleTimeString(undefined, optionsTime); // "12:00 PM"

    return `Published ${prettyDate} at ${prettyTime} â€¢ ${readTime} min read`;
  }

  // === Toggle visibility of the filter options box ===
  document.getElementById('filter-sort-button').addEventListener('click', () => {
    const options = document.getElementById('filter-options');
    options.style.display = (options.style.display === 'none') ? 'block' : 'none';
  });

  // === Fetch blog post files from GitHub ===
  const response = await fetch("https://api.github.com/repos/RyanMDewey/ryanmdewey.github.io/contents/frontend/blog");
  const files = await response.json();

  // === Process and extract blog metadata ===
  let allPosts = await Promise.all(
    files
      .filter(file => file.name.endsWith(".html") && /^\d{4}-\d{2}-\d{2}/.test(file.name)) // Only include properly named blog posts
      .map(async file => {
        const name = file.name.replace(".html", ""); // Remove ".html"
        const [year, month, day, ...titleParts] = name.split("-");
        const title = titleParts.map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(" ");
        const datePart = `${year}-${month}-${day}`;

        // Fetch the GitHub commits for this file to get creation time
        const fileRes = await fetch(`https://api.github.com/repos/RyanMDewey/ryanmdewey.github.io/commits?path=frontend/blog/${file.name}`);
        const fileCommits = await fileRes.json();
        const commitTime = fileCommits.length > 0 ? fileCommits[fileCommits.length - 1].commit.author.date : `${datePart}T12:00:00`;

        // Fetch the blog content to get preview and meta
        const res = await fetch(`./${file.name}`);
        const html = await res.text();

        // Estimate word count and reading time
        const textOnly = html.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
        const wordCount = textOnly.split(' ').length;
        const readTime = Math.ceil(wordCount / 200);

        // Parse category (if any)
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");
        const metaTag = doc.querySelector('meta[name="category"]') || doc.querySelector('#fallback-category');
        const category = metaTag ? (metaTag.getAttribute("content") || metaTag.textContent.trim()) : "Uncategorized";

        // Grab a snippet from first <p> if available
        const preview = html.split("<p>")[1]?.split("</p>")[0] || "";

        // Return the processed blog post data
        return { title, date: datePart, file: file.name, preview, category, readTime, commitTime };
      })
  );

  // === Initialize search with Fuse.js ===
  const fuse = new Fuse(allPosts, { keys: ["title", "preview"], threshold: 0.3 });

  // === Render the blog posts grouped by category ===
  function renderPosts(posts) {
    blogContainer.innerHTML = ""; // Clear previous

    const categories = [...new Set(posts.map(p => p.category))]; // Unique categories

    categories.forEach(category => {
      const catHeader = document.createElement("h2");
      catHeader.textContent = category;
      blogContainer.appendChild(catHeader);

      const section = document.createElement("div");
      section.className = "category-group";

      posts.filter(p => p.category === category).forEach(post => {
        const postElement = document.createElement("div");
        postElement.className = "post-preview fade-in";

        postElement.innerHTML = `
          <h3><a href="./${post.file}">${post.title}</a></h3>
          <p class="post-meta">${formatPublishedDisplay(post.date, post.commitTime, post.readTime)}</p>
          <p class="post-snippet">${post.preview}</p>
        `;

        // Fade-in animation when entering viewport
        const observer = new IntersectionObserver(entries => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              entry.target.classList.add("visible");
              observer.unobserve(entry.target);
            }
          });
        }, { threshold: 0.1 });

        observer.observe(postElement);
        section.appendChild(postElement);
      });

      blogContainer.appendChild(section);
    });
  }

  // === Apply filter (category) or sort (newest/oldest) ===
  function applyFilterAndSort() {
    const selected = filterSelect.value;
    let filteredPosts = [...allPosts];

    if (selected.startsWith('sort-')) {
      if (selected === 'sort-newest') {
        filteredPosts.sort((a, b) => new Date(b.date) - new Date(a.date));
      } else if (selected === 'sort-oldest') {
        filteredPosts.sort((a, b) => new Date(a.date) - new Date(b.date));
      }
    } else if (selected !== "all") {
      filteredPosts = allPosts.filter(post => post.category === selected);
    }

    renderPosts(filteredPosts);
  }

  // === Build filter dropdown options dynamically ===
  const categoryGroup = filterSelect.querySelector('optgroup[label="ðŸ—‚ Categories"]');
  const categories = [...new Set(allPosts.map(p => p.category))];
  categories.forEach(category => {
    const option = document.createElement("option");
    option.value = category;
    option.textContent = category;
    categoryGroup.appendChild(option);
  });

  // === Initial render sorted by newest first ===
  allPosts.sort((a, b) => {
    const aDate = new Date(a.date);
    const bDate = new Date(b.date);
    return bDate - aDate;
  });
  renderPosts(allPosts);

  // === Search typing interaction ===
  searchInput.addEventListener("input", e => {
    const results = fuse.search(e.target.value.trim());
    searchResults.innerHTML = "";

    if (results.length > 0) {
      searchResults.style.display = "block";
      results.slice(0, 5).forEach(r => {
        const resultItem = document.createElement("div");
        resultItem.className = "search-result";
        resultItem.textContent = r.item.title;
        resultItem.onclick = () => window.location.href = `./${r.item.file}`;
        searchResults.appendChild(resultItem);
      });
    } else {
      searchResults.style.display = e.target.value ? "block" : "none";
      const noMatch = document.createElement("div");
      noMatch.className = "search-result";
      noMatch.textContent = "No matches found.";
      searchResults.appendChild(noMatch);
    }
  });

  // === Filter event listener ===
  filterSelect.addEventListener("change", applyFilterAndSort);
});
</script>
</body>
</html>
